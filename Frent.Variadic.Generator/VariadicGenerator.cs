using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace Frent.Variadic.Generator
{
    [Generator(LanguageNames.CSharp)]
    public class VariadicGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(
                ctx => ctx.AddSource("VariadicAttribute.g.cs", Helpers.AttributeString));

            var t = context.SyntaxProvider.ForAttributeWithMetadataName<(ISymbol Symbol, SyntaxNode Node, SemanticModel Model)>(Helpers.AttributeMetadataString,
                [method: DebuggerHidden] (_, _) => true,
                (t, ct) => (t.TargetSymbol, t.TargetNode, t.SemanticModel))
                .Collect()
                .Combine(context.AdditionalTextsProvider.Collect())
                .SelectMany(GroupAttributesIntoModels)
                .SelectMany(GenerateCode);


            context.RegisterImplementationSourceOutput(t, (ctx, s) => ctx.AddSource(s.FileName, s.Code));
        }

        [ThreadStatic]
        private static Dictionary<(TypeDeclarationSyntax, ISymbol), (string From, string Pattern, int Count)[]> _classTable = new();

        private static readonly string[] ToSplit = ["to:\n"];
        private static readonly string[] FromSplit = ["from:\n"];
        static ImmutableArray<GenerationModel> GroupAttributesIntoModels((ImmutableArray<(ISymbol Symbol, SyntaxNode Node, SemanticModel Model)> Data, ImmutableArray<AdditionalText> AdditionText) variadics, CancellationToken ct)
        {
            _classTable ??= new();
            var table = _classTable;

            Dictionary<string, (string, string, int)[]> fileTemplates = variadics
                .AdditionText
                .ToDictionary(a => Path.GetFileNameWithoutExtension(a.Path), a => ParseTemplate(a.GetText()?.ToString() ?? throw new FileLoadException()));

            static (string, string, int)[] ParseTemplate(string template)
            {
                template = template.Replace("\r\n", "\n");
                string[] arr = template.Split(FromSplit, StringSplitOptions.None);
                (string, string, int)[] parsed = new (string, string, int)[arr.Length - 1];

                int arity = int.Parse(arr[0].Substring("arity:".Length));
                int index = 0;
                foreach (var st in arr.AsSpan(1))
                {
                    string[] items = st.Split(ToSplit, StringSplitOptions.None);
                    parsed[index++] = (items[0].TrimEnd(), items[1].TrimEnd(), arity);
                }

                return parsed;
            }

            foreach (var (Symbol, Node, Model) in variadics.Data)
            {
                if (Node is null)
                    continue;
                var parentType = Node?.FirstAncestorOrSelf<TypeDeclarationSyntax>();
                if (parentType is null || Symbol is null)
                    continue;

                if (!table.TryGetValue((parentType, Symbol), out var stack))
                {
                    table[(parentType, Symbol)] = ExtractArguments(Symbol, fileTemplates);
                }
            }

            var arr = _classTable.Select(kvp =>
            {
                CodeBuilder cb = new CodeBuilder(0);

                cb.AppendLine(Helpers.AutoGenerated)
                    .AppendLine("#pragma warning disable CS1591")
                    .AppendLine()
                    .Loop(EnumerateUsings(kvp.Key.Item1.SyntaxTree.GetRoot(ct)), (c, s) => c.AppendLine(s.ToString()), ct)
                    .AppendLine()
                    .Append("namespace ").Append(kvp.Key.Item2.ContainingNamespace).AppendLine(';');

                const string Exclude = "/// <exclude />";
                // hella jank but whatever
                string leadingTrivia = kvp.Key.Item1.AttributeLists.First().GetLeadingTrivia().ToFullString();
                if(leadingTrivia.Contains("/// <variadic />") || leadingTrivia.Contains("/// <inheritdoc cref=\"GenerationServices\"/>"))
                    cb.AppendLine(Exclude);

                cb.Append(kvp.Key.Item1.WithAttributeLists([]).ToFullString().Replace("/// <variadic />", Exclude));
                //cb.Append(Regex.Replace(kvp.Key.Item1.ToFullString(), @"\[Variadic\(""\s*(.*?)\s*"",\s*""\|?(.*?)\|?""\)\]", ""));

                var str = cb.ToString();


                string fileSafeTypeName = kvp.Key.Item2.Name;
                if (fileSafeTypeName.IndexOf('<') is { } t && t != -1)
                    fileSafeTypeName = fileSafeTypeName.Substring(0, t);

                return new GenerationModel
                {
                    SourceCode = cb.ToString().Replace("\r\n", "\n"),
                    FileName = fileSafeTypeName,
                    Attributes = new EquatableArray<(string From, string Pattern, int Count)>(kvp.Value)
                };
            }).ToImmutableArray();
            table.Clear();

            return arr;
        }

        static (string, string, int)[] ExtractArguments(ISymbol symbol, Dictionary<string, (string, string, int)[]> fromFiles)
        {
            var att = symbol.GetAttributes();

            List<(string, string, int)> output = new(att.Length);

            int j = 0;
            for (int i = 0; i < att.Length; i++)
            {
                AttributeData @this = att[i];
                if(@this.AttributeClass?.ToString() == Helpers.AttributeMetadataString)
                {
                    if (@this.ConstructorArguments.Length == 1)
                    {
                        output.AddRange(fromFiles[(string)@this.ConstructorArguments[0].Value!]);
                        continue;
                    }

                    output.Add(((string)@this.ConstructorArguments[0].Value!, (string)@this.ConstructorArguments[1].Value!, (int)@this.ConstructorArguments[2].Value!));
                }
            }

            return output.ToArray();
        }

        static ImmutableArray<(string Code, string FileName)> GenerateCode(GenerationModel ctx, CancellationToken ct)//omg cs ref
        {
            string code = ctx.SourceCode;

            int MaxArity = ctx.Attributes.Items[0].Count;
            var builder = ImmutableArray.CreateBuilder<(string, string)>(MaxArity - 1);

            for (int arity = 2; arity <= MaxArity; arity++)
            {
                string thisRunCode = code;
                foreach (var transform in ctx.Attributes)
                {
                    thisRunCode = Run(thisRunCode, transform.From, transform.Pattern, arity);
                }

                builder.Add((thisRunCode, $"{ctx.FileName}.{arity}.cs"));
            }

            return builder.ToImmutableArray();
        }

        [ThreadStatic]
        static StringBuilder replace = new StringBuilder();

        internal static string Run(string cleanSource, string from, string pattern, int arity)
        {
            replace ??= new();
            replace.Clear();

            bool hasRepeition = ExtractPattern(pattern.AsSpan(), out var prologue, out var epilogue);

            if(!hasRepeition)
            {
                return cleanSource.Replace(from, pattern.Replace("$", arity.ToString()));
            }

            replace.Append(prologue);
            pattern = pattern.Substring(prologue.Length + 1, pattern.Length - epilogue.Length - prologue.Length - 2);

            string segment = string.Empty;
            for (int i = 1; i <= arity; i++)
                replace.Append(segment = pattern.Replace("$", i.ToString()));
            int index;
            if ((index = segment.IndexOf(',')) != -1 && segment.Length - index < 3)
            {
                replace.Remove(replace.Length - (segment.Length - index), segment.Length - index);
            }

            replace.Append(epilogue);

            return cleanSource.Replace(from, replace.ToString());
        }

        private static bool ExtractPattern(ReadOnlySpan<char> pattern, out ReadOnlySpan<char> prologue, out ReadOnlySpan<char> epilogue)
        {
            int firstIndex = pattern.IndexOf('|');
            int lastIndex = pattern.LastIndexOf('|');
            if(firstIndex == -1)
            {
                prologue = default;
                epilogue = default;
                return false;
            }
            prologue = pattern.Slice(0, firstIndex);
            epilogue = pattern.Slice(lastIndex + 1);
            return true;
        }

        static IEnumerable<UsingDirectiveSyntax> EnumerateUsings(SyntaxNode root)
        {
            foreach (var item in root.ChildNodes())
            {
                if (item is UsingDirectiveSyntax usingDirectiveSyntax)
                {
                    yield return usingDirectiveSyntax;
                }
            }
        }

        internal struct GenerationModel
        {
            public string SourceCode;
            public string FileName;
            public EquatableArray<(string From, string Pattern, int Count)> Attributes;
        }

        static bool Launched = false;

        [Conditional("DEBUG")]
        [DebuggerStepThrough]
        [DebuggerHidden]
        internal static void LaunchDebugger()
        {
            if (!Debugger.IsAttached && !Launched)
                Debugger.Launch();
            Launched = true;
        }
    }
}